<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/sharingan.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/sharingan.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="网络层概述       网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输。 要实现网络层任务，需要解决以下主要问题：  网络层向运输层提供怎样的服务(“可靠传输”还是“不可靠传输”) 网络层寻址问题 路由选择问题 路由器依据数据包的目的地址和路由器中的路由表决定从哪个接口转发数据。 路由记录生成：人工配置、路由选择协议自动生成。    因特网(Internet">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-第四章-网络层">
<meta property="og:url" content="https://yuchen-zeta.github.io/2021/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/index.html">
<meta property="og:site_name" content="Yuchen&#39;s Blog">
<meta property="og:description" content="网络层概述       网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输。 要实现网络层任务，需要解决以下主要问题：  网络层向运输层提供怎样的服务(“可靠传输”还是“不可靠传输”) 网络层寻址问题 路由选择问题 路由器依据数据包的目的地址和路由器中的路由表决定从哪个接口转发数据。 路由记录生成：人工配置、路由选择协议自动生成。    因特网(Internet">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(1).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(2).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(3).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(4).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(5).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(6).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(7).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(8).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(9).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(10).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(11).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(12).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(13).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(14).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(15).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(16).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(17).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(18).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(19).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(20).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(21).png">
<meta property="article:published_time" content="2021-11-04T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-04T16:00:00.000Z">
<meta property="article:author" content="Yuchen">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(1).png"><title>计算机网络-第四章-网络层 | Yuchen's Blog</title><link ref="canonical" href="https://yuchen-zeta.github.io/2021/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-feather-alt"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Yuchen's Blog</div><div class="header-banner-info__subtitle">受尽苦难而不厌，此乃修罗之道。——索隆</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">计算机网络-第四章-网络层</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-05</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">10.5k</span></span></div></header><div class="post-body">
        <h1 id="网络层概述">
          <a href="#网络层概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1>
      <p>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong>。</p>
<p>要实现网络层任务，需要解决以下主要问题：</p>
<ul>
<li>网络层向运输层提供怎样的服务(“可靠传输”还是“不可靠传输”)</li>
<li>网络层寻址问题</li>
<li>路由选择问题<ul>
<li>路由器依据数据包的目的地址和路由器中的路由表决定从哪个接口转发数据。</li>
<li>路由记录生成：人工配置、路由选择协议自动生成。</li>
</ul>
</li>
</ul>
<p><strong>因特网(Internet)<strong>是目前全世界用户数量最多的互联网，它使用</strong>TCP/IP协议栈</strong>。</p>
<span id="more"></span>

<p>由于TCP/IP协议栈的网络层使用<strong>网际协议IP</strong>，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为<strong>网际层</strong>。</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(1).png"></p>
<p>注：<strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p>

        <h1 id="网络层提供的两种服务">
          <a href="#网络层提供的两种服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1>
      
        <h2 id="面向连接的虚电路服务">
          <a href="#面向连接的虚电路服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2>
      <p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(2).png"></p>
<ul>
<li>核心思想：<strong>可靠通信由网络来保证。</strong></li>
<li>在双方通信之前，需要先建立<strong>网络层的连接</strong>，也就是**虚电路(Virtual Circuit)**，以保证双方通信所需的一切网络资源。</li>
<li>通信双方沿着<strong>已建立的虚电路发送分组</strong><ul>
<li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li>而电路交换的电话通信是先建立了一条真正的连接。两者类似但不同</li>
</ul>
</li>
<li>目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号(构成虚电路的每一段链路都有一个虚电路编号)。</li>
<li>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方(无差错按序到达、不丢失、不重复)。</li>
<li><strong>通信结束后，需要释放之前所建立的虚电路。</strong></li>
</ul>
<blockquote>
<p>很多广域分组交换网都使用面向连接的虚电路服务。例如，曾经的X.25和逐渐过时的帧中继FR、 异步传输模式ATM等。</p>
</blockquote>
<hr>

        <h2 id="无连接的数据报服务">
          <a href="#无连接的数据报服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2>
      <p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(3).png"></p>
<ul>
<li>核心思想：<strong>可靠通信由用户主机来保证。</strong></li>
<li>在双方通信时，<strong>不需要建立网络层连接</strong>。</li>
<li>每个分组可以<strong>走不同的路径</strong>，因此每个分组的<strong>首部必须携带目的主机的完整地址</strong>。</li>
<li>这种通信方式所传送的<strong>分组可能误码、丢失、重复和失序</strong>。网络层只做到尽最大努力交付。</li>
<li>由于<strong>网络本身不提供端到端的可靠传输服务</strong>，这就使网络中的路由器可以做得比较简单，而且价格低廉(与电信网的交换机相比较)。</li>
<li>因特网采用了这种设计思想，也就是将<strong>复杂的网络处理功能置于因特网的边缘</strong>(用户主机和其内部的运输层)，而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li>
</ul>
<blockquote>
<p><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。<br>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</p>
</blockquote>
<hr>

        <h2 id="虚电路服务和数据报服务的对比">
          <a href="#虚电路服务和数据报服务的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚电路服务和数据报服务的对比" class="headerlink" title="虚电路服务和数据报服务的对比"></a>虚电路服务和数据报服务的对比</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th><strong>对比的方面</strong></th>
<th><strong>虚电路服务</strong></th>
<th><strong>数据报服务</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>思路</strong></td>
<td><strong>可靠通信应当由网络来保证</strong></td>
<td><strong>可靠通信应当由用户主机来保证</strong></td>
</tr>
<tr>
<td><strong>连接的建立</strong></td>
<td><strong>必须有</strong></td>
<td><strong>不需要</strong></td>
</tr>
<tr>
<td><strong>终点地址</strong></td>
<td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td>
<td><strong>每个分组都有终点的完整地址</strong></td>
</tr>
<tr>
<td><strong>分组的转发</strong></td>
<td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td>
<td><strong>每个分组独立选择路由进行转发</strong></td>
</tr>
<tr>
<td><strong>当结点出故障时</strong></td>
<td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td>
<td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td>
</tr>
<tr>
<td><strong>分组的顺序</strong></td>
<td><strong>总是按发送顺序到达终点</strong></td>
<td><strong>到达终点时不一定按发送顺序</strong></td>
</tr>
<tr>
<td><strong>端到端的差错处理和流量控制</strong></td>
<td><strong>可以由网络负责，也可以由用户主机负责</strong></td>
<td><strong>由用户主机负责</strong></td>
</tr>
</tbody></table></div>

        <h1 id="IPv4">
          <a href="#IPv4" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1>
      
        <h2 id="IPv4地址概述">
          <a href="#IPv4地址概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4地址概述" class="headerlink" title="IPv4地址概述"></a>IPv4地址概述</h2>
      <p><strong>IPv4地址</strong>就是给因特网(Internet)上的<strong>每一台主机(或路由器)的每一个接口</strong>分配一在全世界范围内是<strong>唯一的32比特的标识符</strong>。</p>
<p>IP地址由因特网名字和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配。</p>
<ul>
<li>我国用户可向亚太网络信息中心APNIC(Asia Pacific Network Information Center)申请IP地址，需要缴费。</li>
<li>2011年2月3日，互联网号码分配管理局IANA(由ICANN行使职能)宣布，IPv4地址已经分配完毕。</li>
<li>我国在2014至201 5年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。</li>
</ul>
<p>IPv4地址的编址方法经历了如下三个历史阶段：</p>
<ul>
<li>1981年，分类编址</li>
<li>1985年，划分子网</li>
<li>1993年，无分类编址</li>
</ul>

        <h2 id="分类编址的IPv4地址">
          <a href="#分类编址的IPv4地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类编址的IPv4地址" class="headerlink" title="分类编址的IPv4地址"></a>分类编址的IPv4地址</h2>
      <p>每一类地址都由<strong>网络号</strong>和<strong>主机号</strong>组成，一个IP地址在整个互联网范围内是唯一的。</p>
<ul>
<li>只有A类、B类和C类地址可分配给网络中的主机或路由器的各接口</li>
<li><strong>主机号</strong>为“全0”的地址是<strong>网络地址</strong>，不能分配给主机或路由器的各接口</li>
<li><strong>主机号</strong>为“全1”的地址是<strong>广播地址</strong>，不能分配给主机或路由器的各接口</li>
<li><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(4).png" width="50%"></li>
</ul>
<hr>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(5).png"></p>
<p>说明：</p>
<ul>
<li>A类地址：<ul>
<li>最小网络号0，保留不指派</li>
<li>最大网络号127，作为本地环回测试地址，不指派<br>范围：127.0.0.1 — 127.255.255.254</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(6).png"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(7).png"></p>
<hr>
<blockquote>
<p><strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：(网络号和主机号)</p>
</blockquote>
<ul>
<li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li>
<li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li>
</ul>
<blockquote>
<p><strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p>
</blockquote>
<ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li>
</ul>

        <h2 id="划分子网的的IPv4地址">
          <a href="#划分子网的的IPv4地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#划分子网的的IPv4地址" class="headerlink" title="划分子网的的IPv4地址"></a>划分子网的的IPv4地址</h2>
      <blockquote>
<p>为什么要划分子网？<br>答：主要还是因为ABC类网络的主机数量相差太多，一个公司想申请个网络号，C类只有254个不够用，而B类又有65534个，造成了大量的剩余浪费，IP地址空间利用率很低。而且若公司想要搭三个网络，那还得再申请两个网络号，申请网络号要需要等待时间和费用，而且会增加路由器中路由表的记录，因此，把一个网络再次划分是很好的办法，从主机号借一部分作为子网号。</p>
</blockquote>
<p>为了使用子网，我们引入了<strong>子网掩码</strong>来划分，从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</p>
<p>这种做法叫做<strong>划分子网</strong> (subnetting) 。划分子网已成为互联网的正式标准协议。</p>
<p><strong>划分子网</strong>纯属<strong>一个网络内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的<strong>一个网络</strong>。</p>
<ul>
<li>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号<ul>
<li>子网掩码使用<strong>连续的比特1来对应网络号和子网号</strong></li>
<li>子网掩码使用<strong>连续的比特0来对应主机号</strong></li>
<li>将划分子网的IPv4地址与其相应的子网掩码进行<strong>逻辑与</strong>运算就可得到IPv4地址所在子网的<strong>网络地址</strong></li>
</ul>
</li>
<li><strong>给定一个分类的IP地址和其相应的子网掩码，就可知道子网划分的细节：</strong><ul>
<li><strong>划分出的子网数量</strong></li>
<li><strong>每个子网可分配的IP地址数量</strong></li>
<li><strong>每个子网的网络地址和广播地址</strong></li>
<li><strong>每个子网可分配的最小和最大地址</strong></li>
</ul>
</li>
<li>默认的子网掩码是指在未划分子网的情况下使用的子网掩码：<ul>
<li>A类: 255.0.0.0 | B类: 255.255.0.0 | C类: 255.255.255.0</li>
</ul>
</li>
<li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li>
</ul>

        <h2 id="无分类编址的IPv4地址">
          <a href="#无分类编址的IPv4地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2>
      <blockquote>
<p>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是<strong>数量巨大的C类</strong>网因为<strong>其地址空间太小</strong>并<strong>没有得到充分使用</strong>，而因特网的IP地址仍在加速消耗，整个<strong>IPv4地址空间面临全部耗尽的威胁</strong>。</p>
</blockquote>
<p>为此，因特网工程任务组IETF又提出了采用<strong>无分类编址</strong>的方法来解决IP地址紧张的问题，同时还专门成立IPv6工作组负责研究新版本IP以彻底解决IP地址耗尽问题。</p>
<p>1993年，IETF发布了<strong>无分类域间路由选择CIDR</strong>(Classless Inter-Domain Routing)的RFC文档：RFC 1517~1519和1520。</p>
<ul>
<li><strong>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念；</strong></li>
<li><strong>CIDR可以更加有效地分配IPv4的地址空间</strong>， 并且可以在新的IPv6使用之前允许因特网的规模继续增长。</li>
</ul>
<p>CIDR使用“<strong>斜线记法</strong>”，或称CIDR记法。即在IPv4地址后面加上斜线”/”，在<strong>斜线后面写上网络前缀所占的比特数量</strong>。</p>
<p><strong>CIDR 最主要的特点：</strong></p>
<ul>
<li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li>
<li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li>
</ul>
<p>CIDR实际上是<strong>将网络前缀都相同的连续的IP地址组成一个“CIDR地址块”</strong></p>
<ul>
<li>我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节:<ul>
<li><strong>地址块的最小地址</strong></li>
<li><strong>地址块的最大地址</strong></li>
<li><strong>地址块中的地址数量</strong></li>
<li><strong>地址块聚合某类网络(A类、B类或C类)的数量</strong></li>
<li><strong>地址掩码 (也可继续称为子网掩码)</strong></li>
</ul>
</li>
</ul>
<p>路由聚合(构造超网)的方法是找共同前缀。<strong>网络前缀越长，聚合地址块越小，路由越具体。</strong></p>
<p>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为<strong>最长前缀匹配</strong>，因为这样的路由更具体。</p>

        <h2 id="IPv4地址的应用规划">
          <a href="#IPv4地址的应用规划" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2>
      <p><strong>定长的子网掩码FLSM（Fixed Length Subnet Mask）</strong></p>
<ul>
<li>使用<strong>同一个子网掩码</strong>来划分子网</li>
<li>采用<strong>定长</strong>的子网掩码划分，只能划分出<strong>2^n</strong>个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</li>
<li>因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</li>
</ul>
<blockquote>
<p><strong>划分子网的IPv4就是定长的子网掩码</strong></p>
</blockquote>
<hr>
<p><strong>变长的子网掩码VLSM（Variable Length Subnet Mask）</strong></p>
<ul>
<li>使用<strong>不同的子网掩码</strong>来划分子网</li>
<li>子网划分方式灵活：可以按需分配</li>
<li>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</li>
</ul>
<blockquote>
<p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p>
</blockquote>

        <h1 id="IP数据报的发送和转发过程">
          <a href="#IP数据报的发送和转发过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h1>
      <p><strong>主机发送IP数据报：</strong></p>
<p>判断目的主机是否与自己在同一个网络：</p>
<ul>
<li>若在<strong>同一个网络</strong>，则属于<strong>直接交付</strong>；</li>
<li>若<strong>不在同一个网络</strong>，则属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>(路由器)，由默认网关帮忙转发；</li>
</ul>
<p>通过目的地址IP和源地址的子网掩码进行逻辑与运算得到目的网络地址。</p>
<hr>
<p><strong>路由器转发IP数据报：</strong></p>
<ol>
<li><strong>检查IP数据报首部是否出错：</strong><ul>
<li>若出错，则直接丢弃该IP数据报并通告源主机；</li>
<li>若没有出错，则进行转发；</li>
</ul>
</li>
<li><strong>根据IP数据报的目的地址在路由表中查找匹配的条目：</strong><ul>
<li>若找到匹配的条目，则转发给条目中指示的下一跳；</li>
<li>若找不到，则丢弃该IP数据报并通告源主机；</li>
</ul>
</li>
</ol>
<p>注：路由器隔离广播域，目标地址位广播地址的数据报不转发。</p>

        <h1 id="静态路由配置">
          <a href="#静态路由配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h1>
      <p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器<strong>人工配置路由表</strong>。</p>
<ul>
<li>这种人工配置方式简单、开销小。但<strong>不能及时适应网络状态(流量、拓扑等)的变化</strong>。</li>
<li>一般只在小规模网络中采用。</li>
</ul>
<hr>
<p>使用静态路由配置可能出现以下<strong>导致产生路由环路</strong>的错误：</p>
<ul>
<li>配置错误<ul>
<li>为防止IP数据报在路由环路中兜圈，在IP数据报首部设有生存时间TTL字段</li>
</ul>
</li>
<li>聚合了不存在的网络<ul>
<li>为了防止聚合时将不存在的网络也囊括进去，可以对不存在的网络设置黑洞路由</li>
</ul>
</li>
<li>网络故障<ul>
<li>若某网络出问题，路由器将该网络的路由表项删除并设置黑洞路由</li>
</ul>
</li>
</ul>
<hr>
<p>路由条目的类型：</p>
<ul>
<li>直连网络</li>
<li>静态路由(人工配置)</li>
<li>动态路由(路由选择协议)</li>
</ul>
<p>特殊的静态路由条目</p>
<ul>
<li>默认路由(目的网络为0.0.0.0，地址掩码为0.0.0.0)<ul>
<li>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</li>
</ul>
</li>
<li>特定主机路由(目的网络为特定主机的IP地址，地址掩码为255.255.255.255)<ul>
<li>一般用于网络管理人员对网络的管理和测试</li>
<li>多条路由可选，匹配路由最具体的</li>
</ul>
</li>
<li>黑洞路由(下一跳为null0)</li>
</ul>

        <h1 id="路由选择协议">
          <a href="#路由选择协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1>
      <p>路由选择可分为静态路由选择和动态路由选择。</p>
<p>静态路由选择：</p>
<ul>
<li>由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由。</li>
<li>这种人工配置方式简单、开销小。但<strong>不能及时适应网络状态(流量、拓扑等)的变化</strong>。</li>
<li>一般只在小规模网络中采用。</li>
</ul>
<p>动态路由选择：</p>
<ul>
<li>路由器通过路由选择协议自动获取路由信息。</li>
<li>比较复杂、开销比较大。能较好地适应网络状态的变化。</li>
<li>适用于大规模网络。</li>
</ul>
<hr>
<p>因特网是全球最大的互联网络，它所采用的路由选择协议具有以下三个特点：</p>
<ul>
<li>自适应：动态路由选择，能较好地适应网络状态的变化</li>
<li>分布式：路由器之间交换路由信息</li>
<li>分层次：将整个因特网划分为许多较小的自治系统AS(Autonomous System)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(8).png"></p>
<p>自治系统之间的路由选择简称为<strong>域间路由选择</strong><br>域间路由选择使用<strong>外部网关协议EGP</strong>这个类别的路由选择协议</p>
<p>自治系统内部的路由选择简称为<strong>域内路由选择</strong><br>域内路由选择使用<strong>内部网关协议IGP</strong>这个类别的路由选择协议</p>
<p><strong>网关协议</strong>的名称又可称为<strong>路由协议</strong></p>
<hr>
<p><strong>常见的路由选择协议</strong></p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(9).png"></p>
<hr>

        <h2 id="路由器的基本结构">
          <a href="#路由器的基本结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器的基本结构" class="headerlink" title="路由器的基本结构"></a>路由器的基本结构</h2>
      <p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(10).png"></p>
<p>路由器结构可划分为两大部分：</p>
<p><strong>1、分组转发部分</strong></p>
<p>由三部分构成</p>
<ul>
<li>交换结构</li>
<li>一组输入端口：<ol>
<li>信号从某个输入端口进入路由器</li>
<li>物理层将信号转换成比特流，送交数据链路层处理</li>
<li>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</li>
<li>如果送交网络层的分组是普通待转发的数据分组，则根据分组首部中的目的地址进行查表转发</li>
<li>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</li>
</ol>
</li>
<li>一组输出端口<ol>
<li>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</li>
<li>数据链路层将数据分组封装成帧，交给物理层处理</li>
<li>物理层将帧看成比特流将其变换成相应的电信号进行发送</li>
</ol>
</li>
</ul>
<blockquote>
<p>路由器的各端口还会有输入缓冲区和输出缓冲区<br>输入缓冲区用来暂存新进入路由器但还来不及处理的分组<br>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p>
</blockquote>
<p>注：<strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p>
<hr>
<p><strong>2、路由选择部分</strong></p>
<ul>
<li>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</li>
<li>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</li>
<li>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></li>
</ul>
<hr>

        <h2 id="路由信息协议RIP">
          <a href="#路由信息协议RIP" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h2>
      <p><strong>路由信息协议RIP</strong>(Routing Infomation Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一， 其相关标准文档为RFC 1058。</p>
<p>RIP要求自治系统AS内的每-个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“**距离向量D-V(Distance-Vector)**”。</p>
<p>RIP使用<strong>跳数</strong>(Hop Count)作为度量(Metric)来<strong>衡量到达目的网络的距离</strong>。</p>
<ul>
<li>路由器到直连网络的距离定义为1；</li>
<li>路由器到非直连网络的距离定义为所经过的路由器数加1；</li>
<li>允许一条路径最多只能包含15个路由器。 <strong>“距离”等于16时相当于不可达。</strong>因此，<strong>RIP只适用于小型互联网。</strong></li>
</ul>
<hr>
<p>RIP认为<strong>好的路由</strong>就是“<strong>距离短</strong>”的路由，也就是<strong>所通过路由器数量最少的路由。</strong></p>
<ul>
<li>当到达同一目的网络有多条“距离相等”的路由时，可以进行<strong>等价负载均衡</strong>。</li>
</ul>
<p>RIP包含以下三个要点：</p>
<ul>
<li><strong>和谁交换信息</strong>：仅和<strong>相邻路由器</strong>交换信息</li>
<li><strong>交换什么信息</strong>：自己的<strong>路由表</strong></li>
<li><strong>何时交换信息</strong>：<strong>周期性交换</strong>(例如每30秒发送一次RIP更新报文)</li>
</ul>
<hr>
<p>RIP的基本工作过程：</p>
<ol>
<li>路由器刚开始工作时，<strong>只知道自己到直连网络的距离为1</strong>；</li>
<li>每个路由器仅<strong>和相邻路由器周期性地交换并更新路由信息</strong>。</li>
<li>若干次交换和更新后，<strong>每个路由器都知道到达本AS内各网络的最短距离和下一跳地址</strong>，称为收敛。</li>
</ol>
<p>RIP的路由条目的更新规则：</p>
<ul>
<li>发现了新的网络，添加</li>
<li>到达目的网络，相同下一跳，最新消息，更新</li>
<li>到达目的网络，不同下一跳，新路由优势，更新</li>
<li>到达目的网络，不同下一跳，新路由劣势，不更新</li>
<li>到达目的网络，不同下一跳， 等价负载均衡</li>
</ul>
<hr>
<p>RIP存在“<strong>坏消息传播得慢</strong>”的问题，又称为<strong>路由环路</strong>或<strong>距离无穷计数</strong>问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。例如：</p>
<ul>
<li>限制最大路径距离为15 (16表示不可达)<ul>
<li>环路兜圈直到距离为16时停下，所以说坏消息要传播很久才会停下来</li>
</ul>
</li>
<li>当路由表发生变化时就立即发送更新报文(即“<strong>触发更新</strong>”) ,而不仅是周期性发送</li>
<li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即“水平分割”)</li>
</ul>
<p>注：这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定。</p>

        <h2 id="开放最短路径优先OSPF">
          <a href="#开放最短路径优先OSPF" class="heading-link"><i class="fas fa-link"></i></a><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h2>
      <p>**开放最短路径优先 OSPF (Open Shortest Path First)**是为克服RIP的缺点在1989年开发出来的。</p>
<ul>
<li>“开放” 表明OSPF协议不是受某-家厂商控制，而是公开发表的。</li>
<li>“最短路径优先”是因为使用了Dijkstra提出的<strong>最短路径算法</strong>SPF。</li>
</ul>
<p><strong>OSPF是基于链路状态</strong>的，而不像RIP那样是基于距离向量的。</p>
<p>OSPF采用SPF算法计算路由，从算法上保证了<strong>不会产生路由环路</strong>。</p>
<p><strong>OSPF不限制网络规模</strong>，更新效率高，<strong>收敛速度快</strong>。</p>
<p>链路状态是指本路由器都和<strong>哪些路由器相邻</strong>，以及相应**链路的“代价”(cost)**。</p>
<ul>
<li>“代价” 用来表示费用、距离、时延、带宽等等。这些都由网络管理人员来决定。</li>
</ul>
<hr>
<p>使用OSPF的每个路由器都会产生**链路状态通告LSA(Link State Advertisement)**。</p>
<p>LSA中包含以下内容：</p>
<ul>
<li>直连网络的链路状态信息</li>
<li>邻居路由器的链路状态信息</li>
</ul>
<p>LSA被封装在<strong>链路状态更新分组LSU</strong>中，采用洪泛法发送。</p>
<p>使用OSPF的每个路由器都有一个<strong>链路状态数据库LSDB</strong>，用于存储LSA。</p>
<p>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致。</p>
<p>使用OSPF的各路由器<strong>基于LSDB进行最短路径优先SPF计算</strong>，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</p>
<ul>
<li>各路由器可以通过LSDB构建带权有向图，对该图进行Dijkstra的最短路径优先算法，就可以得到各路由器为跟的最短路径。</li>
</ul>
<hr>
<p>OSPF有以下五种分组类型：</p>
<ul>
<li>问候(Hello) 分组<ul>
<li>用来发现和维护邻居路由器的可达性。</li>
</ul>
</li>
<li>数据库描述 (Database Description)分组<ul>
<li>向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li>
</ul>
</li>
<li>链路状态请求 (Link State Request)分组<ul>
<li>向邻居路由器请求发送某些链路状态项目的详细信息。</li>
</ul>
</li>
<li>链路状态更新 (Link State Update)分组<ul>
<li>路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态。</li>
</ul>
</li>
<li>链路状态确认 (Link State Acknowledgment)分组<ul>
<li>这是对链路状态更新分组的确认分组。</li>
</ul>
</li>
</ul>
<hr>
<p>OSPF在多点接入网络中路由器邻居关系的建立</p>
<blockquote>
<p>所谓的多点接入网络，就是说这些接入的路由器都互为邻居关系</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(11).png"></p>
<p>为了减少hello分组发送的数量，OSPF采用 <strong>选举指定路由器DR</strong>(designated router)和<strong>备用的指定路由器BDR</strong>(backup designated router)</p>
<ul>
<li>所有的非DR/BDR只与DR/BDR建立邻居关系</li>
<li>非DR/BDR之间通过DR/BDR交换信息</li>
</ul>
<hr>
<p>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域(Area) 。</p>
<p>划分区域的好处就是把利用洪泛法交换链路状体信息的范围局限于每一 个区域而不是整个自治系统，这就减少了整个网络上的通信量。</p>

        <h2 id="边界网关协议BGP">
          <a href="#边界网关协议BGP" class="heading-link"><i class="fas fa-link"></i></a><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2>
      <p>BGP(Border Gateway Protocol)是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议。</p>
<blockquote>
<p>在上面介绍了内部网关协议IGP (例如路由信息协议RIP或开放最短路径优先OSPF)，它们都是<strong>设法使分组在一个自治系统内尽可能有效地从源网络传输到目的网络，无需考虑自治系统外部其他方面的策略。</strong></p>
</blockquote>
<p>在不同自治系统内，度量路由的“代价”(距离， 带宽，费用等)可能不同。<br>因此，对于自治系统之间的路由选择,使用“代价”作为度量来寻找最佳路由是不行的。需要采用<strong>外部网关协议EGP</strong>(例如边界网关协议BGP)</p>
<p>自治系统之间的路由选择必须考虑相关策略(政治,经济,安全等)</p>
<p>BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子)，而并非要寻找一条最佳路由。</p>
<hr>
<p>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“<strong>BGP发言人</strong>”</p>
<p>不同自治系统的BGP发言人要交换路由信息，首先必须建立<strong>TCP连接</strong>，端口号为179</p>
<ul>
<li>在此TCP连接上交换BGP报文以建立<strong>BGP会话</strong></li>
<li>利用BGP会话**交换路由信息(**例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等)</li>
<li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的<strong>邻站</strong>(neighbor) 或<strong>对等站</strong>(peer)</li>
</ul>
<p>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。</p>
<p>BGP发言人<strong>交换网络可达性的信息</strong>(要到达某个网络所要经过的一系列自治系统)</p>
<p>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就<strong>根据</strong>所采用的<strong>策略</strong>从收到的路由信息中<strong>找出到达各自治系统的较好的路由</strong>。也就是构造出树形结构、<strong>不存在回路的自治系统连通图</strong>。</p>
<hr>
<p>边界网关协议BGP适用于多级结构的因特网</p>
<p>BGP-4有以下四种报文</p>
<ul>
<li>OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化。</li>
<li>UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由。</li>
<li>KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性。</li>
<li>NOTIFICATION(通知)报文：用来发送检测到的差错。</li>
</ul>

        <h2 id="直接封装RIP、OSPF、BGP报文的协议">
          <a href="#直接封装RIP、OSPF、BGP报文的协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#直接封装RIP、OSPF、BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF、BGP报文的协议"></a>直接封装RIP、OSPF、BGP报文的协议</h2>
      <p>分别是UDP、IP、TCP</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(12).png"></p>

        <h1 id="IPv4数据报的首部格式">
          <a href="#IPv4数据报的首部格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h1>
      <p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(13).png"></p>
<p>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</p>
<p><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></p>
<ul>
<li>可选字段  长度从1个字节到40个字节不等。用来支持排错、测量及安全等措施。  可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用。</li>
<li>填充字段  确保首部长度为4字节的整数倍。使用全0进行填充。</li>
</ul>
<hr>
<ul>
<li>版本  占4比特，表示IP协议的版本。  通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4 (即IPv4)。</li>
<li>首部长度  占4比特，表示IP数据报首部的长度。该字段的取值以4字节为单位。  最小十进制取值为5，表示IP数据报首部只有20字节固定部分。  最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分。</li>
<li>区分服务  占8比特，用来获得更好的服务。  该字段在旧标准中叫做服务类型，但实际上一直没有被使用过，1998年， 因特网工程任务组IETF把这个字段改名为区分服务。  利用该字段的不同数值可提供不同等级的服务质量。  只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段。</li>
<li>总长度  占16比特，表示IP数据报的总长度(首部+数据载荷)。  最大取值为十进制的65535，以字节为单位。</li>
</ul>
<hr>
<blockquote>
<p>以下三个字段共同用于IP数据报分片。</p>
</blockquote>
<p>扩：以太网的最大传送单元MTU为1500字节。</p>
<ul>
<li>标识  占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。  IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。</li>
<li>标志  占3比特，各比特含义如下：<ul>
<li>DF位：1表示不允许分片，0表示允许分片；</li>
<li>MF位：1表示”后面还有分片”，0表示“这是最后一个分片”；</li>
<li>保留位：必须为0。</li>
</ul>
</li>
<li>片偏移  占13比特， 指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。  片偏移以8个字节为单位。</li>
</ul>
<hr>
<ul>
<li>生存时间TTL  占8比特，表示IP数据报的生存时间。  最初以秒为单位，最大生存周期为255秒；路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则就丢弃。  现在以”跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0就转发，否则就丢弃。</li>
<li>协议  占8比特，指明IPv4数据报的数据部分是何种协议数据单元。  常用的一些协议和相应的协议字段值如下。<ul>
<li>ICMP：1，IGMP：2，TCP：6，UDP：17，IPv6：41，OSPF：89</li>
</ul>
</li>
<li>首部检验和  占16比特，用来检测首部在传输过程中是否出现差错。比CRC检验码简单，称为因特网检验和。  IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段(生存时间、标志、片偏移等)的取值可能发生变化。  由于IP层本身并不提供可靠传输的服务，并且计算首部校验和是一项耗时的操作。因此在IPv6中，路由器不再计算首部校验和，从而更快转发IP数据报。</li>
</ul>
<hr>
<ul>
<li>源IP地址和目的IP地址各占32比特，用来填写 发送该IP数据报的源主机的IP地址 和 接收该IP数据报的目的主机的IP地址。</li>
</ul>

        <h1 id="网际控制报文协议ICMP">
          <a href="#网际控制报文协议ICMP" class="heading-link"><i class="fas fa-link"></i></a><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1>
      <p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了<strong>网际控制报文协议ICMP</strong>(Internet Control Message Protocol)。</p>
<p>主机或路由器使用ICMP来发送<strong>差错报告报文</strong>和<strong>询问报文</strong>。</p>
<blockquote>
<p><strong>重点</strong>：<strong>ICMP报文被封装在IP数据报</strong>中发送。</p>
</blockquote>

        <h2 id="ICMP差错报告报文">
          <a href="#ICMP差错报告报文" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h2>
      <p>ICMP差错报告报文共有以下五种：</p>
<ul>
<li>终点不可达  <img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(14).png"><ul>
<li>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</li>
<li>具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误。</li>
</ul>
</li>
<li>源点抑制  <img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(15).png"><ul>
<li>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文,使源点知道应当把数据报的发送速率放慢。</li>
</ul>
</li>
<li>时间超过  <img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(16).png"><ul>
<li>当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段的值减1。</li>
<li>若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文。</li>
<li>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃,也会向源点发送时间超过报文。</li>
</ul>
</li>
<li>参数问题  <img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(17).png"><ul>
<li>当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</li>
</ul>
</li>
<li>改变路由(重定向)  <img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(18).png"><ul>
<li>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。</li>
</ul>
</li>
</ul>
<hr>
<p>以下情况不应发送ICMP差错报告报文:</p>
<ul>
<li>对ICMP差错报告报文不再发送ICMP差错报告报文</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li>
<li>对具有多播地址的数据报都不发送ICMP差错报告报文</li>
<li>对具有特殊地址(如127.0.0.0或0.0.0.0) 的数据报不发送ICMP差错报告报文</li>
</ul>
<hr>

        <h2 id="ICMP询问报文">
          <a href="#ICMP询问报文" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h2>
      <p>常用的ICMP询问报文有以下两种：</p>
<ul>
<li><strong>回送请求和回答</strong><ul>
<li>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。</li>
<li>收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。</li>
<li>这种询问报文用来<strong>测试目的站是否可达</strong>及了解其有关状态。</li>
</ul>
</li>
<li><strong>时间戳请求和回答</strong><ul>
<li>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。</li>
<li>在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从<br>1900年1月1日起到当前时刻一共有多少秒。</li>
<li>这种询问报文用来<strong>进行时钟同步和测量时间</strong>。</li>
</ul>
</li>
</ul>

        <h2 id="ICMP应用">
          <a href="#ICMP应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP应用" class="headerlink" title="ICMP应用"></a>ICMP应用</h2>
      <p><strong>分组网间探测PING（Packet InterNet Groper）</strong></p>
<ul>
<li>用来测试主机或路由器间的连通性</li>
<li>应用层直接使用网际层的ICMP (没有通过运输层的TCP或UDP)</li>
<li>用ICMP回送请求和回答报文</li>
</ul>
<p><strong>跟踪路由（traceroute）</strong></p>
<p>用来测试IP数据报从源主机到达目的主机要经过哪些路由器</p>
<p>Windows版本</p>
<ul>
<li>tracert命令</li>
<li>应用层直接使用网际层ICMP</li>
<li>使用了ICMP回送请求和回答报文以及差错报告报文</li>
</ul>
<p>Unix版本</p>
<ul>
<li>traceroute命令</li>
<li>在运输层使用UDP协议</li>
<li>仅使用ICMP差错报告报文</li>
</ul>
<p>工作原理：通过发送TTL为n的报文，待收到ICMP差错报文(时间超过)就可以知道跳数为n的路由器，发送1~n的报文就可以知道整条路径上经过的路由器。</p>

        <h1 id="VPN-amp-NAT">
          <a href="#VPN-amp-NAT" class="heading-link"><i class="fas fa-link"></i></a><a href="#VPN-amp-NAT" class="headerlink" title="VPN &amp; NAT"></a>VPN &amp; NAT</h1>
      
        <h2 id="虚拟专用网VPN">
          <a href="#虚拟专用网VPN" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h2>
      <p><strong>VPN(Virtual Private Network)</strong></p>
<p><strong>利用公用的因特网</strong>作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网</strong>。</p>
<p>同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为<strong>内联网VPN</strong></p>
<p>有时一个机构的VPN需要有某些外部机构(通常就是合作伙伴)参加进来。这样的VPN就称为<strong>外联网VPN</strong>。</p>
<p>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为<strong>远程接入VPN</strong>。</p>
<hr>
<p>由于IPv4地址的紧缺，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。因此，<strong>虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址</strong>，而不是需要申请的、在因特网上使用的公有地址。</p>
<p>因特网数字分配机构IANA划分了IPv4地址空间中特殊地址，其中有部分地址是无需申请的、可自由分配的专用地址，或称私有地址</p>
<ul>
<li><strong>10.0.0.0~10.255.255.255(10/8地址块)</strong></li>
<li><strong>172.16.0.0~172.31.255.255(172.16/12地址块)</strong></li>
<li><strong>192.168.0.0~192.168.255.255(192.168/16地址块)</strong></li>
</ul>
<blockquote>
<p>注：私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信；<br>私有地址只能用作本地地址而不能用作全球地址；<br>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发。</p>
</blockquote>
<p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p>
<p>举例说明：部门A向部门B发送数据流程</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(19).png"></p>
<p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p>
<p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</p>

        <h2 id="网络地址转换NAT">
          <a href="#网络地址转换NAT" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2>
      <p><strong>NAT(Network Address Translation)</strong></p>
<p>虽然因特网采用了无分类编址方式来减缓IPv4地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有被解除。</p>
<p>1994年提出了一种网络地址转换NAT的方法再次<strong>缓解了IPv4地址空间即将耗尽的问题</strong>。</p>
<p>NAT能使大量<strong>使用内部专用地址的专用网络用户共享少量外部全球地址</strong>来访问因特网上的主机和资源。</p>
<hr>
<p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p>
<ul>
<li>这需要在专用网络连接到因特网的路由器上安装NAT软件</li>
</ul>
<p>装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。</p>
<p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p>
<hr>
<p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(20).png"></p>
<p>因特网上的这台主机给源主机发回数据报</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211105(21).png"></p>
<p>那么问题来了，如果NAT路由器有N各全球IP地址，那最多也就只有N个内网主机可以同时和因特网上的主机通信。</p>
<p>如何解决：由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。<br>这样，<strong>用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信</strong>。这种将端口号和IP地址起进行转换的技术叫作**网络地址与端口号转换NAPT(Network Address and Port Translation)**。</p>
<blockquote>
<p>我们现在用的很多家用路由器都是这种NART路由器</p>
</blockquote>
<p>对于一些P2P网络应用， 需要<strong>外网主机主动与内网主机进行通信，在通过NAT时会遇到问题</strong>，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。</p>
<ul>
<li>因为外网主机不能首先发起与内网主机的通信，内网中没有对应表项</li>
</ul>
<p>由于<strong>NAT对外网屏蔽了内网主机的网络地址</strong>，能为内网的主机提供一定的安全保护。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://yuchen-zeta.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"><span class="paginator-prev__text">操作系统-第一章-概述</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">
          网络层概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">
          网络层提供的两种服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.</span> <span class="toc-text">
          面向连接的虚电路服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.2.</span> <span class="toc-text">
          无连接的数据报服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.</span> <span class="toc-text">
          虚电路服务和数据报服务的对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IPv4"><span class="toc-number">3.</span> <span class="toc-text">
          IPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv4%E5%9C%B0%E5%9D%80%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">
          IPv4地址概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E7%9A%84IPv4%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">
          分类编址的IPv4地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E7%9A%84%E7%9A%84IPv4%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.</span> <span class="toc-text">
          划分子网的的IPv4地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E7%9A%84IPv4%E5%9C%B0%E5%9D%80"><span class="toc-number">3.4.</span> <span class="toc-text">
          无分类编址的IPv4地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv4%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BA%94%E7%94%A8%E8%A7%84%E5%88%92"><span class="toc-number">3.5.</span> <span class="toc-text">
          IPv4地址的应用规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">
          IP数据报的发送和转发过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">
          静态路由配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.</span> <span class="toc-text">
          路由选择协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">
          路由器的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AERIP"><span class="toc-number">6.2.</span> <span class="toc-text">
          路由信息协议RIP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88OSPF"><span class="toc-number">6.3.</span> <span class="toc-text">
          开放最短路径优先OSPF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEBGP"><span class="toc-number">6.4.</span> <span class="toc-text">
          边界网关协议BGP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%B0%81%E8%A3%85RIP%E3%80%81OSPF%E3%80%81BGP%E6%8A%A5%E6%96%87%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.5.</span> <span class="toc-text">
          直接封装RIP、OSPF、BGP报文的协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">
          IPv4数据报的首部格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP"><span class="toc-number">8.</span> <span class="toc-text">
          网际控制报文协议ICMP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87"><span class="toc-number">8.1.</span> <span class="toc-text">
          ICMP差错报告报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP%E8%AF%A2%E9%97%AE%E6%8A%A5%E6%96%87"><span class="toc-number">8.2.</span> <span class="toc-text">
          ICMP询问报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP%E5%BA%94%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">
          ICMP应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VPN-amp-NAT"><span class="toc-number">9.</span> <span class="toc-text">
          VPN &amp; NAT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN"><span class="toc-number">9.1.</span> <span class="toc-text">
          虚拟专用网VPN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT"><span class="toc-number">9.2.</span> <span class="toc-text">
          网络地址转换NAT</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/blog-logo.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">羽尘</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/yuchen-zeta/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2058149863&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Yuchen</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-space-shuttle"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>