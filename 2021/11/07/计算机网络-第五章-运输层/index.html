<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/sharingan.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/sharingan.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="运输层概述        之前所介绍的计算机网络体系结构中的物理层、数据链路层以及网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。  如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-第五章-运输层">
<meta property="og:url" content="https://yuchen-zeta.github.io/2021/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="Yuchen&#39;s Blog">
<meta property="og:description" content="运输层概述        之前所介绍的计算机网络体系结构中的物理层、数据链路层以及网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。  如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(1).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(2).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(3).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(4).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(5).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(6).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(7).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(8).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(9).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(10).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(11).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(12).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(13).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(14).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(15).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(16).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(17).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(18).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(19).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(20).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(21).png">
<meta property="og:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(22).png">
<meta property="article:published_time" content="2021-11-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-06T16:00:00.000Z">
<meta property="article:author" content="Yuchen">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(1).png"><title>计算机网络-第五章-运输层 | Yuchen's Blog</title><link ref="canonical" href="https://yuchen-zeta.github.io/2021/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-feather-alt"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Yuchen's Blog</div><div class="header-banner-info__subtitle">受尽苦难而不厌，此乃修罗之道。——索隆</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">计算机网络-第五章-运输层</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8.8k</span></span></div></header><div class="post-body">
        <h1 id="运输层概述">
          <a href="#运输层概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h1>
      <blockquote>
<p>之前所介绍的计算机网络体系结构中的<strong>物理层</strong>、<strong>数据链路层</strong>以及<strong>网络层</strong>，它们共同解决了将主机通过异构网络互联起来所面临的问题，<strong>实现了主机到主机的通信。</strong><br>但实际上在计算机网络中进行<strong>通信的真正实体是位于通信两端主机中的进程</strong>。</p>
</blockquote>
<p><strong>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务</strong>，运输层协议又称为端到端协议。</p>
<span id="more"></span>

<p>运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就<strong>好像是在两个运输层实体之间有一条端到端的逻辑通信信道</strong>。</p>
<p>根据应用需求的不同，<strong>因特网的运输层</strong>为应用层提供了两种不同的运输协议，即<br><strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>，这两种协议就是本章要讨论的主要内容。</p>

        <h1 id="端口号、复用和分用">
          <a href="#端口号、复用和分用" class="heading-link"><i class="fas fa-link"></i></a><a href="#端口号、复用和分用" class="headerlink" title="端口号、复用和分用"></a>端口号、复用和分用</h1>
      
        <h2 id="端口号">
          <a href="#端口号" class="heading-link"><i class="fas fa-link"></i></a><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2>
      <p>运行在计算机上的进程使用<strong>进程标识符PID</strong>来标志。</p>
<p>因特网上的计算机并不是使用统一的操作系统, 不同的操作系统(windows, Linux, Mac OS)又使用<strong>不同格式的进程标识符</strong>。</p>
<p>为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用<strong>统一的方法对TCP/IP体系的应用进程进行标识</strong>。</p>
<p>TCP/IP体系的运输层使用<strong>端口号</strong>来区分应用层的不同应用进程。</p>
<ul>
<li>端口号使用<strong>16比特</strong>表示，取值范围<strong>0~65535</strong>：<ul>
<li><strong>熟知端口号</strong>：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20，HTTP使用80，DNS使用53</li>
<li><strong>登记端口号</strong>：1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如：Microsoft RDP微软远程桌面使用的端口是3389</li>
<li><strong>短暂端口号</strong>：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ul>
</li>
<li><strong>端口号只具有本地意义</strong>，即端口号只是为了标识本计算机应用层中的各进程，在因特网中不同计算机中的相同端口号是没有联系的。</li>
</ul>

        <h2 id="复用与分用">
          <a href="#复用与分用" class="heading-link"><i class="fas fa-link"></i></a><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h2>
      <p><strong>发送方的复用和接收方的分用</strong></p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(1).png"></p>
<p><strong>多个进程</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p>
<p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>数据称为 <strong>分用</strong>。</p>
<p>运输层使用端口号来区分不同应用进程。</p>
<p><strong>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</strong></p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(2).png"></p>

        <h1 id="UDP和TCP的对比">
          <a href="#UDP和TCP的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h1>
      <ul>
<li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP/IP体系结构<strong>运输层</strong>中的两个重要协议</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(3).png"></p>
<ul>
<li>使用UDP协议的通信双方可以随时发送数据</li>
<li>使用TCP协议的通信双方 ，在进行通信之前，必须使用三报文握手来建立连接；数据传输结束后，必须使用四报文挥手来释放连接。</li>
</ul>
<p>正因如此，UDP支持单播、多播以及广播，而TCP只支持单播(因为要握手挥手)</p>
<hr>
<p>下面来看具体的使用情况：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(4).png"></p>
<ul>
<li>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</li>
</ul>
<blockquote>
<p>换句话说，UDP是面向应用报文的</p>
</blockquote>
<hr>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(5).png"></p>
<p>发送方</p>
<ul>
<li>TCP会把应用进程交付下来的数据块看作是一连串<strong>无结构的字节流</strong>，TCP并不知道这些待传送的字节流的含义，TCP会将他们<strong>编号</strong>，并<strong>存储</strong>在自己发送<strong>缓存</strong>中；</li>
<li>TCP会根据发送策略，提取<strong>一定量的字节构建TCP报文</strong>并发送。</li>
</ul>
<p>接收方</p>
<ul>
<li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在<strong>接收缓存</strong>中；一方面将接收缓存中的<strong>一些字节交付给应用进程</strong>；</li>
<li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系；</li>
<li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据。</li>
</ul>
<blockquote>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p>
</blockquote>
<hr>
<ul>
<li>UDP向上层提供无连接不可靠传输服务<br>(适用于IP电话、视频会议等实时应用)</li>
<li>TCP向上层提供面向连接的可靠传输服务<br>(适用于要求可靠传输的应用，例如文件传输)</li>
</ul>
<hr>
<p>再来看一下UDP与TCP的首部格式</p>
<p>UDP：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(6).png"></p>
<p>TCP：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(7).png"></p>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <p><strong>用户数据报协议UDP(User Datagram Protocol)</strong></p>
<ul>
<li>无连接</li>
<li>支持一对一、一对多、多对一和多对多交互通信。</li>
<li>对应用层交付的报文直接打包，面向应用报文</li>
<li>尽最大努力交付，也就是不可靠；不使用流量控制和拥塞控制。</li>
<li>首部开销小，仅8字节</li>
</ul>
<p><strong>传输控制协议TCP(Transmission Control Protocol)</strong></p>
<ul>
<li>面向连接</li>
<li>每一条TCP连接只能有两个端点EP，只能是一对一通信。</li>
<li>面向字节流</li>
<li>可靠传输，使用流量控制和拥塞控制。</li>
<li>首部最小20字节，最大60字节</li>
</ul>

        <h1 id="TCP的流量控制">
          <a href="#TCP的流量控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1>
      <ul>
<li>一般来说，我们总是希望数据传输得更快一些。<ul>
<li>但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</li>
</ul>
</li>
<li>所谓流量控制(<strong>flow control</strong>)就是<strong>让发送方的发送速率不要太快，要让接收方来得及接收</strong>。</li>
<li>利用<strong>滑动窗口</strong>机制可以很方便地在TCP连接上实现对发送方的流量控制。<ul>
<li>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。</li>
<li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文(零窗口探测报文也有重传计时器，不用担心丢失)</li>
</ul>
</li>
</ul>
<p>流程见下图：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(8).png"></p>
<p>发送窗口调控为0后，接收方调整报文若在发送过程中丢失可能导致发送方等待调控报文，接收方等待数据报文，引发死锁局面，为打破该局面，使用计时器和零窗口探测报文：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(9).png"></p>

        <h1 id="TCP的拥塞控制">
          <a href="#TCP的拥塞控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1>
      <p>在某段时间，若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分， 网络性能就要变坏</strong>。这种情况就叫做**拥塞(congestion)**。</p>
<ul>
<li>在计算机网络中的链路容量(即带宽)、 交换结点中的缓存和处理机等,都是网络的资源。</li>
</ul>
<p>若<strong>出现拥塞而不进行控制</strong>，整个网络的<strong>吞吐量将随输入负荷的增大而下降</strong>。</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(10).png"></p>
<hr>
<p><strong>拥塞控制的四种算法</strong></p>
<ul>
<li>慢开始(slow-start)</li>
<li>拥塞避免(congestion avoidance)</li>
<li>快重传(fast retransmit)</li>
<li>快恢复(fast recovery)</li>
</ul>
<p>下面介绍这四种拥塞控制算法的基本原理，假定如下条件：</p>
<ol>
<li>数据是<strong>单方向传送</strong>，而另一个方向只传送确认。</li>
<li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小<strong>由网络的拥塞程度来决定</strong>。</li>
<li>以<strong>最大报文段MSS的个数</strong>为讨论问题的单位，而不是以字节为单位。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(11).png"></p>
<ul>
<li>发送方维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值<strong>取决于网络的拥塞程度</strong>，并且<strong>动态变化</strong>。<ul>
<li>拥塞窗口<strong>cwnd的维护原则</strong>：只要网络<strong>没有出现拥塞</strong>，拥塞窗口就再<strong>增大</strong>一些；但只要网络<strong>出现拥塞</strong>， 拥塞窗口就<strong>减少</strong>一些。</li>
<li>判断出现<strong>网络拥塞的依据</strong>：没有按时收到应当到达的确认报文(即<strong>发生超时重传</strong>)。</li>
</ul>
</li>
<li>发送方将拥塞窗口作为发送窗口swnd，即swnd = cwnd。<ul>
<li>真正的发送窗口值 = Min(接收方窗口值，拥塞窗口值)</li>
</ul>
</li>
<li>发送方还需维护一个慢开始门限ssthresh状态变量：<ul>
<li>当cwnd &lt; ssthresh时，使用慢开始算法；</li>
<li>当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法；</li>
<li>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li>
</ul>
</li>
</ul>
<hr>
<p>下面具体介绍拥塞控制的四种算法，并用拥塞窗口与传输轮次的坐标图表示</p>
<p>传输轮次：</p>
<ul>
<li>指发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li>
<li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li>
<li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li>
</ul>
<p>拥塞窗口：</p>
<ul>
<li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li>
</ul>

        <h2 id="慢开始-slow-start">
          <a href="#慢开始-slow-start" class="heading-link"><i class="fas fa-link"></i></a><a href="#慢开始-slow-start" class="headerlink" title="慢开始(slow-start)"></a>慢开始(slow-start)</h2>
      <ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>思路：由小到大逐渐增大拥塞窗口数值(加倍增加，指数增加)。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(12).png"></p>
<ul>
<li>拥塞窗口成倍增加，直到<strong>大于慢开始门限值</strong>，此后要<strong>改用拥塞避免</strong>算法</li>
</ul>

        <h2 id="拥塞避免-congestion-avoidance">
          <a href="#拥塞避免-congestion-avoidance" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞避免-congestion-avoidance" class="headerlink" title="拥塞避免(congestion avoidance)"></a>拥塞避免(congestion avoidance)</h2>
      <ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。每经过一个传输轮次，拥塞窗口 <strong>cwnd = cwnd + 1</strong>。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(13).png"></p>
<p>若在传输过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传。</p>
<p>若出现了重传计时器超时，那么系统判断网络很可能出现了拥塞，此时：</p>
<ul>
<li>将ssthresh值更新为发生拥塞时cwnd值的一半</li>
<li>将cwnd重置为1，并重新开始执行慢开始算法</li>
</ul>
<blockquote>
<p>注：“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；<br>“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞；</p>
</blockquote>
<hr>
<p>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法(TCP Tahoe版本)。</p>
<ul>
<li>有时，<strong>个别报文段</strong>会在网络中<strong>丢失，</strong>但实际上网络<strong>并未发生拥塞</strong>。<ul>
<li>这将导致发送方超时重传，并误认为网络发生了拥塞；</li>
<li>发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。</li>
</ul>
</li>
</ul>
<p>1990年又增加了两个新的拥塞控制算法(<strong>改进TCP的性能</strong>)，这就是快重传和快恢复(TCP Reno版本)。</p>

        <h2 id="快重传-fast-retransmit">
          <a href="#快重传-fast-retransmit" class="heading-link"><i class="fas fa-link"></i></a><a href="#快重传-fast-retransmit" class="headerlink" title="快重传(fast retransmit)"></a>快重传(fast retransmit)</h2>
      <p>所谓快重传，就是使发送方<strong>尽快进行重传</strong>，而<strong>不是等超时重传计时器</strong>超时再重传。</p>
<ul>
<li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>；</li>
<li>即使收到了失序的报文段也要立即发出对<strong>已收到</strong>的报文段的<strong>重复确认</strong>；</li>
<li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段<strong>立即重传</strong>，而不是等该报文段的超时重传计时器超时再重传。</li>
<li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞(进而降低拥塞窗口cwnd为1)。使用快重传可以使整个网络的吞吐量提高约20%。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(14).png"></p>

        <h2 id="快恢复-fast-recovery">
          <a href="#快恢复-fast-recovery" class="heading-link"><i class="fas fa-link"></i></a><a href="#快恢复-fast-recovery" class="headerlink" title="快恢复(fast recovery)"></a>快恢复(fast recovery)</h2>
      <p>发送方一旦<strong>收到3个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而<strong>执行快恢复算法</strong>。</p>
<ul>
<li>发送方将<strong>慢开始门限ssthresh值</strong>和<strong>拥塞窗口cwnd值</strong>调整为当前窗口的<strong>一半</strong>；<strong>开始执行拥塞避免算法</strong>。</li>
<li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些, 即等于新的ssthresh + 3。<ul>
<li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络</li>
<li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</li>
<li>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</li>
</ul>
</li>
</ul>
<hr>
<p>整体算法执行过程：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(15).png"></p>

        <h1 id="TCP超时重传时间的选择">
          <a href="#TCP超时重传时间的选择" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h1>
      <p>超时重传时间的选择是TCP最复杂的问题之一。</p>
<p>简单来说，超时重传时间RTO应该略大于往返时间RTT，但是由于TCP下面是复杂的互联网，不同情况下的RTT相差很大</p>
<ul>
<li>如果超时重传时间RTO的值设置得比RTT的值小很多，这会引起报文段不必要的重传，使网络负荷增大</li>
<li>如果超时重传时间RTO的值设置得远大于RTT的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</li>
</ul>
<p>所以<strong>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO</strong>。</p>
<p>但是可以利用每次测量得到的RTT样本，计算加权平均往返时间RTTs(又称为平滑的往返时间)，显然，超时重传时间RTO应略大于加权平均往返时间RTTs.</p>
<hr>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(16).png"></p>
<hr>
<p>实际上，RTT的测量还是比较复杂的，尤其是出现超时重传时，由于发送的是同样的TCP报文段，那么RTT的起始时间到底是开始发送报文段时的时间还是重传时的时间很难判断。</p>
<p>针对<strong>出现超时重传时无法测准往返时间RTT</strong>的问题，Karn提出了一个算法：</p>
<p>在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。</p>
<ul>
<li>这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。</li>
</ul>
<p>因此，要对<strong>Karn算法进行修正</strong>。方法是：报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是将新RTO的值取为旧RTO值的2倍。</p>

        <h1 id="TCP可靠传输的实现">
          <a href="#TCP可靠传输的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1>
      <p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(17).png"></p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(18).png"></p>
<p>TCP基于<strong>以字节为单位的滑动窗口</strong>来实现可靠传输。</p>
<ul>
<li>发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去；</li>
<li>接收方只接收序号落入发送窗口内的数据。</li>
</ul>
<p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，<strong>发送方的发送窗口并不总是和接收方的接收窗口一样大</strong>。</p>
<ul>
<li>网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。</li>
<li>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。</li>
</ul>
<p>对于<strong>不按序到达的数据应如何处理</strong>，TCP并无明确规定。</p>
<ul>
<li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。</li>
<li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong>。</li>
</ul>
<p>TCP要求接收方必须有<strong>累积确认和捎带确认机制</strong>，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</p>
<ul>
<li><strong>接收方不应过分推迟发送确认</strong>，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。  TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 1122]。</li>
<li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li>
</ul>
<p><strong>TCP的通信是全双工通信。</strong>通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</p>

        <h1 id="TCP的运输连接管理">
          <a href="#TCP的运输连接管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1>
      <p>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</p>
<p>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(19).png"></p>
<p>TCP的运输连接管理就是使运输连接的建立和释放都能正常地运行。</p>

        <h2 id="TCP的连接建立">
          <a href="#TCP的连接建立" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2>
      <p>TCP的连接建立要解决以下三个问题：</p>
<ul>
<li>使TCP双方能够确知对方的存在；</li>
<li>使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等)；</li>
<li>使TCP双方能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配。</li>
</ul>
<hr>
<p><strong>TCP使用“三报文握手”建立连接</strong></p>
<ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
</ul>
<p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p>
<hr>
<p>过程：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(20).png"></p>
<blockquote>
<p>最初两端的TCP进程都处于<strong>关闭状态</strong>。</p>
</blockquote>
<ul>
<li>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。<ul>
<li>例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。</li>
</ul>
</li>
<li>之后，就准备接受TCP客户端进程的连接请求，此时TCP服务器进程就进入<strong>监听状态</strong>，等待TCP客户端进程的连接请求。</li>
</ul>
<blockquote>
<p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接。</p>
</blockquote>
<blockquote>
<p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接。</p>
</blockquote>
<ul>
<li>TCP客户进程也是首先创建传输控制块。</li>
<li>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP<strong>连接请求报文段</strong>，并进入<strong>同步已发送状态。</strong>  TCP连接请求报文段首部中：<ul>
<li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段；</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号。</li>
</ul>
  注：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号。</li>
<li>TCP服务器进程收到TCP连接请求报文段后，如果<strong>同意建立连接</strong>，则向TCP客户进程发送TCP<strong>连接请求确认报文段</strong>，并进入<strong>同步已接收状态。</strong>  TCP连接请求确认报文段首部中：<ul>
<li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段；</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号；</li>
<li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号(seq)的确认。</li>
</ul>
  注：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号。</li>
<li>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个<strong>普通的TCP确认报文段</strong>，并进入<strong>连接已连接状态。</strong>  普通的TCP确认报文段首部中：<ul>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1；</li>
<li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认。</li>
</ul>
  注：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号，下次发送数据报文段序号仍是x+1。</li>
<li>TCP服务器进程收到该确认报文段后也进入连接已建立状态</li>
</ul>
<blockquote>
<p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输。</p>
</blockquote>
<hr>
<p>思考：三报文握手最后一次握手能不能去掉，反正都收到服务器端的连接请求确认了，直接进入连接已建立状态不是也可以吗？</p>
<p>其实第三次握手主要是<strong>防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</strong>。</p>
<blockquote>
<p>发送一个连接请求报文段后超时了，客户端重传一个连接请求，并建立连接，通信结束后释放连接，结果好巧不巧，结束以后，之前超时的那个连接请求报文段”反复横跳“后到达服务器端了，服务器端就同意连接，发送连接请求确认，并自己进入连接已建立状态，一直等着客户端和他通信，然而客户端并不知道此时有连接建立，这样服务器端就会白白浪费资源。</p>
</blockquote>

        <h2 id="TCP的连接释放">
          <a href="#TCP的连接释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a><strong>TCP的连接释放</strong></h2>
      <ul>
<li>TCP 连接释放过程比较复杂。</li>
<li>数据传输结束后，通信的<strong>双方都可以在数据传送结束后发出连接释放的通知</strong></li>
</ul>
<hr>
<p><strong>TCP通过“四报文挥手”来释放连接</strong></p>
<p>过程：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(21).png"></p>
<blockquote>
<p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p>
</blockquote>
<ul>
<li>假设TCP客户进程的应用进程通知其主动关闭TCP连接，TCP客户进程会发送TCP<strong>连接释放报文段</strong>，并进入<strong>终止等待1状态</strong>  TCP连接释放报文段首部中：<ul>
<li><strong>终止位FIN</strong>和<strong>确认位ACK</strong>的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1。</li>
</ul>
  请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</li>
<li>TCP服务器进程收到TCP连接释放报文段后，会发送一个<strong>普通的TCP确认报文段</strong>并进入<strong>关闭等待状态</strong>  普通的TCP确认报文段首部中：<ul>
<li><strong>确认位ACK</strong>的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li>
</ul>
</li>
</ul>
<blockquote>
<p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接。此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了。<br>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了。<br>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭。</p>
</blockquote>
<ul>
<li>TCP客户进程收到<strong>TCP确认报文段</strong>后就进入<strong>终止等待2状态</strong>，等待TCP服务器进程发出的<strong>TCP连接释放报文段。</strong></li>
<li>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接。</li>
</ul>
<blockquote>
<p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</p>
</blockquote>
<ul>
<li>TCP服务器进程发送TCP连接释放报文段并进入<strong>最后确认状态。</strong>  该报文段首部中：<ul>
<li><strong>终止位FIN</strong>和<strong>确认位ACK</strong>的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送；</li>
<li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</li>
</ul>
</li>
<li>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送<strong>普通的TCP确认报文段</strong>，之后进入<strong>时间等待状态。</strong>  该报文段首部中：<ul>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</li>
</ul>
</li>
<li>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过<strong>2倍MSL</strong>后才能进入关闭状态。<ul>
<li><strong>MSL(Maximum Segment Lifetime)，最长报文段寿命，RFC793建议为2分钟</strong>， 这时间其实有点太长了，TCP允许根据具体情况使用更小的MSL。</li>
</ul>
</li>
</ul>
<hr>
<p>思考：TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<p>时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<blockquote>
<p>要是客户端发送完确定报文段后就进入关闭状态不管事儿了，万一确认报文段丢失了，服务器端收不到确认报文，那么超时后又会重传连接释放报文段，但是客户端已经关闭了，不理服务器了，那服务器就只好一直超时重发而且还没用。<br>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
</blockquote>
<hr>

        <h2 id="TCP保活计时器">
          <a href="#TCP保活计时器" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP保活计时器" class="headerlink" title="TCP保活计时器"></a><strong>TCP保活计时器</strong></h2>
      <p>TCP双方建立了连接以后，TCP客户进程所在的主机突然出现了故障，那么TCP服务器进程以后就不能再收到TCP客户进程发来的数据，因此，应当采取措施使TCP服务器进程不要再白白等待下去，为此引入了保活计时器。</p>
<ul>
<li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动<strong>保活计时器</strong>(2小时定时)。</li>
<li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则<strong>当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段</strong>，以后则每隔75秒钟发送一次。 若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li>
</ul>

        <h1 id="TCP报文段的首部格式">
          <a href="#TCP报文段的首部格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1>
      <p>为了实现可靠传输，TCP采用了<strong>面向字节流</strong>的方式。</p>
<p>但TCP在发送数据时，是从发送缓存取出一部分或全部<strong>字节</strong>并给其添加一个首部使之成为<strong>TCP报文段</strong>后进行发送。</p>
<ul>
<li>一个TCP报文段由首部和数据载荷两部分构成；</li>
<li>TCP的全部功能都体现在它首部中各字段的作用。</li>
</ul>
<p>下面具体说明：</p>
<p><img src="https://raw.githubusercontent.com/yuchen-zeta/images/main/blog/pic_bed/20211107(22).png"></p>
<ul>
<li><p>源端口：占16比特，写入源端口号，用来<strong>标识发送该TCP报文段的应用进程</strong>。</p>
</li>
<li><p>目的端口：占16比特，写入目的端口号，用来<strong>标识接收该TCP报文段的应用进程</strong>。</p>
</li>
<li><p>序号seq：占32比特，取值范围[0,2^32-1]，序号增加到最后一个后，下一个序号就又回到0。用来<strong>指出本TCP报文段数据载荷的第一个字节的序号</strong>。</p>
</li>
<li><p>确认号ack：占32比特，取值范围[0,2^32-1]，确认号增加到最后一个后，下一个确认号就又回到0。用来<strong>指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认</strong>。</p>
<ul>
<li>若确认号=n,则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</li>
</ul>
</li>
<li><p>数据偏移：占4比特，并以4字节为单位。用来<strong>指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远</strong>。</p>
<ul>
<li>这个字段实际上是指出了TCP报文段的首部长度。<br>首部固定长度为20字节，因此数据偏移字段的最小值为(0101)2<br>首部最大长度为60字节，因此数据偏移字段的最大值为(1111)2</li>
</ul>
</li>
<li><p>保留：占6比特，保留为今后使用，但目前应置为0。</p>
</li>
<li><p>紧急标志位URG：取值为1时<strong>紧急指针字段有效</strong>；取值为0时紧急指针字段无效。</p>
</li>
<li><p>确认标志位ACK：取值为1时<strong>确认号字段才有效</strong>；取值为0时确认号字段无效。</p>
<ul>
<li>TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。</li>
</ul>
</li>
<li><p>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会<strong>尽快上交应用进程</strong>，而不必等到接收缓存都填满后再向上交付。</p>
</li>
<li><p>复位标志位RST：用来<strong>复位</strong>TCP连接。</p>
<ul>
<li>当RST置1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。</li>
<li>RST置1还可以用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</li>
</ul>
</li>
<li><p>同步标志位SYN：在TCP连接建立时用来<strong>同步序号</strong>。</p>
</li>
<li><p>终止标志位FIN：用来<strong>释放</strong>TCP连接。</p>
</li>
<li><p>窗口：占16比特，以字节为单位。<strong>指出发送本报文段的一方的接收窗口</strong>。</p>
<ul>
<li>窗口值作为接收方让发送方设置其发送窗口的依据。(需要注意，发送窗口还取决于拥塞窗口的大小)</li>
<li>这是以接收方的接收能力来控制发送方的发送能力，也就是所谓的流量控制。</li>
</ul>
</li>
<li><p>校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。<br>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p>
</li>
<li><p>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。</p>
<ul>
<li>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。</li>
</ul>
</li>
<li><p>选项：</p>
<ul>
<li>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。</li>
<li>窗口扩大选项：为了扩大窗口(提高吞吐率)。</li>
<li>时间戳选项：<ul>
<li>用来计算往返时间RTT</li>
<li>用于处理序号超范围的情况，又称为防止序号绕回PAWS.</li>
</ul>
</li>
<li>选择确认选项</li>
</ul>
</li>
<li><p>选项：</p>
<ul>
<li>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。</li>
<li>窗口扩大选项：为了扩大窗口(提高吞吐率)。</li>
<li>时间戳选项：<ul>
<li>用来计算往返时间RTT</li>
<li>用于处理序号超范围的情况，又称为防止序号绕回PAWS.</li>
</ul>
</li>
<li>选择确认选项</li>
</ul>
</li>
<li><p>填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除</p>
</li>
</ul>
<p>(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的)</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://yuchen-zeta.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">计算机网络-第六章-应用层</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/"><span class="paginator-prev__text">计算机网络-第四章-网络层</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">
          运输层概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%E3%80%81%E5%A4%8D%E7%94%A8%E5%92%8C%E5%88%86%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">
          端口号、复用和分用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">2.1.</span> <span class="toc-text">
          端口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">
          复用与分用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.</span> <span class="toc-text">
          UDP和TCP的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.</span> <span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">
          TCP的流量控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">
          TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B-slow-start"><span class="toc-number">5.1.</span> <span class="toc-text">
          慢开始(slow-start)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D-congestion-avoidance"><span class="toc-number">5.2.</span> <span class="toc-text">
          拥塞避免(congestion avoidance)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0-fast-retransmit"><span class="toc-number">5.3.</span> <span class="toc-text">
          快重传(fast retransmit)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%81%A2%E5%A4%8D-fast-recovery"><span class="toc-number">5.4.</span> <span class="toc-text">
          快恢复(fast recovery)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">6.</span> <span class="toc-text">
          TCP超时重传时间的选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">
          TCP可靠传输的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">
          TCP的运输连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">
          TCP的连接建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="toc-number">8.2.</span> <span class="toc-text">
          TCP的连接释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">
          TCP保活计时器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">
          TCP报文段的首部格式</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/blog-logo.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">羽尘</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/yuchen-zeta/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2058149863&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Yuchen</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-space-shuttle"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>